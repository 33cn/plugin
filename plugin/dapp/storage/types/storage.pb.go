// Code generated by protoc-gen-go. DO NOT EDIT.
// source: storage.proto

package types

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// 后面如果有其他数据模型可继续往上面添加
type Storage struct {
	// Types that are valid to be assigned to Value:
	//	*Storage_ContentStorage
	//	*Storage_HashStorage
	//	*Storage_LinkStorage
	//	*Storage_EncryptStorage
	//	*Storage_EncryptShareStorage
	Value                isStorage_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Storage) Reset()         { *m = Storage{} }
func (m *Storage) String() string { return proto.CompactTextString(m) }
func (*Storage) ProtoMessage()    {}
func (*Storage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{0}
}
func (m *Storage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Storage.Unmarshal(m, b)
}
func (m *Storage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Storage.Marshal(b, m, deterministic)
}
func (dst *Storage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Storage.Merge(dst, src)
}
func (m *Storage) XXX_Size() int {
	return xxx_messageInfo_Storage.Size(m)
}
func (m *Storage) XXX_DiscardUnknown() {
	xxx_messageInfo_Storage.DiscardUnknown(m)
}

var xxx_messageInfo_Storage proto.InternalMessageInfo

type isStorage_Value interface {
	isStorage_Value()
}

type Storage_ContentStorage struct {
	ContentStorage *ContentOnlyNotaryStorage `protobuf:"bytes,1,opt,name=contentStorage,proto3,oneof"`
}
type Storage_HashStorage struct {
	HashStorage *HashOnlyNotaryStorage `protobuf:"bytes,2,opt,name=hashStorage,proto3,oneof"`
}
type Storage_LinkStorage struct {
	LinkStorage *LinkNotaryStorage `protobuf:"bytes,3,opt,name=linkStorage,proto3,oneof"`
}
type Storage_EncryptStorage struct {
	EncryptStorage *EncryptNotaryStorage `protobuf:"bytes,4,opt,name=encryptStorage,proto3,oneof"`
}
type Storage_EncryptShareStorage struct {
	EncryptShareStorage *EncryptShareNotaryStorage `protobuf:"bytes,5,opt,name=encryptShareStorage,proto3,oneof"`
}

func (*Storage_ContentStorage) isStorage_Value()      {}
func (*Storage_HashStorage) isStorage_Value()         {}
func (*Storage_LinkStorage) isStorage_Value()         {}
func (*Storage_EncryptStorage) isStorage_Value()      {}
func (*Storage_EncryptShareStorage) isStorage_Value() {}

func (m *Storage) GetValue() isStorage_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Storage) GetContentStorage() *ContentOnlyNotaryStorage {
	if x, ok := m.GetValue().(*Storage_ContentStorage); ok {
		return x.ContentStorage
	}
	return nil
}

func (m *Storage) GetHashStorage() *HashOnlyNotaryStorage {
	if x, ok := m.GetValue().(*Storage_HashStorage); ok {
		return x.HashStorage
	}
	return nil
}

func (m *Storage) GetLinkStorage() *LinkNotaryStorage {
	if x, ok := m.GetValue().(*Storage_LinkStorage); ok {
		return x.LinkStorage
	}
	return nil
}

func (m *Storage) GetEncryptStorage() *EncryptNotaryStorage {
	if x, ok := m.GetValue().(*Storage_EncryptStorage); ok {
		return x.EncryptStorage
	}
	return nil
}

func (m *Storage) GetEncryptShareStorage() *EncryptShareNotaryStorage {
	if x, ok := m.GetValue().(*Storage_EncryptShareStorage); ok {
		return x.EncryptShareStorage
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Storage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Storage_OneofMarshaler, _Storage_OneofUnmarshaler, _Storage_OneofSizer, []interface{}{
		(*Storage_ContentStorage)(nil),
		(*Storage_HashStorage)(nil),
		(*Storage_LinkStorage)(nil),
		(*Storage_EncryptStorage)(nil),
		(*Storage_EncryptShareStorage)(nil),
	}
}

func _Storage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Storage)
	// value
	switch x := m.Value.(type) {
	case *Storage_ContentStorage:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContentStorage); err != nil {
			return err
		}
	case *Storage_HashStorage:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HashStorage); err != nil {
			return err
		}
	case *Storage_LinkStorage:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LinkStorage); err != nil {
			return err
		}
	case *Storage_EncryptStorage:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncryptStorage); err != nil {
			return err
		}
	case *Storage_EncryptShareStorage:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncryptShareStorage); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Storage.Value has unexpected type %T", x)
	}
	return nil
}

func _Storage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Storage)
	switch tag {
	case 1: // value.contentStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContentOnlyNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &Storage_ContentStorage{msg}
		return true, err
	case 2: // value.hashStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HashOnlyNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &Storage_HashStorage{msg}
		return true, err
	case 3: // value.linkStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LinkNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &Storage_LinkStorage{msg}
		return true, err
	case 4: // value.encryptStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncryptNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &Storage_EncryptStorage{msg}
		return true, err
	case 5: // value.encryptShareStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncryptShareNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &Storage_EncryptShareStorage{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Storage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Storage)
	// value
	switch x := m.Value.(type) {
	case *Storage_ContentStorage:
		s := proto.Size(x.ContentStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Storage_HashStorage:
		s := proto.Size(x.HashStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Storage_LinkStorage:
		s := proto.Size(x.LinkStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Storage_EncryptStorage:
		s := proto.Size(x.EncryptStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Storage_EncryptShareStorage:
		s := proto.Size(x.EncryptShareStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type StorageAction struct {
	// Types that are valid to be assigned to Value:
	//	*StorageAction_ContentStorage
	//	*StorageAction_HashStorage
	//	*StorageAction_LinkStorage
	//	*StorageAction_EncryptStorage
	//	*StorageAction_EncryptShareStorage
	Value                isStorageAction_Value `protobuf_oneof:"value"`
	Ty                   int32                 `protobuf:"varint,6,opt,name=ty,proto3" json:"ty,omitempty"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *StorageAction) Reset()         { *m = StorageAction{} }
func (m *StorageAction) String() string { return proto.CompactTextString(m) }
func (*StorageAction) ProtoMessage()    {}
func (*StorageAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{1}
}
func (m *StorageAction) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StorageAction.Unmarshal(m, b)
}
func (m *StorageAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StorageAction.Marshal(b, m, deterministic)
}
func (dst *StorageAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StorageAction.Merge(dst, src)
}
func (m *StorageAction) XXX_Size() int {
	return xxx_messageInfo_StorageAction.Size(m)
}
func (m *StorageAction) XXX_DiscardUnknown() {
	xxx_messageInfo_StorageAction.DiscardUnknown(m)
}

var xxx_messageInfo_StorageAction proto.InternalMessageInfo

type isStorageAction_Value interface {
	isStorageAction_Value()
}

type StorageAction_ContentStorage struct {
	ContentStorage *ContentOnlyNotaryStorage `protobuf:"bytes,1,opt,name=contentStorage,proto3,oneof"`
}
type StorageAction_HashStorage struct {
	HashStorage *HashOnlyNotaryStorage `protobuf:"bytes,2,opt,name=hashStorage,proto3,oneof"`
}
type StorageAction_LinkStorage struct {
	LinkStorage *LinkNotaryStorage `protobuf:"bytes,3,opt,name=linkStorage,proto3,oneof"`
}
type StorageAction_EncryptStorage struct {
	EncryptStorage *EncryptNotaryStorage `protobuf:"bytes,4,opt,name=encryptStorage,proto3,oneof"`
}
type StorageAction_EncryptShareStorage struct {
	EncryptShareStorage *EncryptShareNotaryStorage `protobuf:"bytes,5,opt,name=encryptShareStorage,proto3,oneof"`
}

func (*StorageAction_ContentStorage) isStorageAction_Value()      {}
func (*StorageAction_HashStorage) isStorageAction_Value()         {}
func (*StorageAction_LinkStorage) isStorageAction_Value()         {}
func (*StorageAction_EncryptStorage) isStorageAction_Value()      {}
func (*StorageAction_EncryptShareStorage) isStorageAction_Value() {}

func (m *StorageAction) GetValue() isStorageAction_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *StorageAction) GetContentStorage() *ContentOnlyNotaryStorage {
	if x, ok := m.GetValue().(*StorageAction_ContentStorage); ok {
		return x.ContentStorage
	}
	return nil
}

func (m *StorageAction) GetHashStorage() *HashOnlyNotaryStorage {
	if x, ok := m.GetValue().(*StorageAction_HashStorage); ok {
		return x.HashStorage
	}
	return nil
}

func (m *StorageAction) GetLinkStorage() *LinkNotaryStorage {
	if x, ok := m.GetValue().(*StorageAction_LinkStorage); ok {
		return x.LinkStorage
	}
	return nil
}

func (m *StorageAction) GetEncryptStorage() *EncryptNotaryStorage {
	if x, ok := m.GetValue().(*StorageAction_EncryptStorage); ok {
		return x.EncryptStorage
	}
	return nil
}

func (m *StorageAction) GetEncryptShareStorage() *EncryptShareNotaryStorage {
	if x, ok := m.GetValue().(*StorageAction_EncryptShareStorage); ok {
		return x.EncryptShareStorage
	}
	return nil
}

func (m *StorageAction) GetTy() int32 {
	if m != nil {
		return m.Ty
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*StorageAction) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _StorageAction_OneofMarshaler, _StorageAction_OneofUnmarshaler, _StorageAction_OneofSizer, []interface{}{
		(*StorageAction_ContentStorage)(nil),
		(*StorageAction_HashStorage)(nil),
		(*StorageAction_LinkStorage)(nil),
		(*StorageAction_EncryptStorage)(nil),
		(*StorageAction_EncryptShareStorage)(nil),
	}
}

func _StorageAction_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*StorageAction)
	// value
	switch x := m.Value.(type) {
	case *StorageAction_ContentStorage:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.ContentStorage); err != nil {
			return err
		}
	case *StorageAction_HashStorage:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.HashStorage); err != nil {
			return err
		}
	case *StorageAction_LinkStorage:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LinkStorage); err != nil {
			return err
		}
	case *StorageAction_EncryptStorage:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncryptStorage); err != nil {
			return err
		}
	case *StorageAction_EncryptShareStorage:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.EncryptShareStorage); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("StorageAction.Value has unexpected type %T", x)
	}
	return nil
}

func _StorageAction_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*StorageAction)
	switch tag {
	case 1: // value.contentStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(ContentOnlyNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &StorageAction_ContentStorage{msg}
		return true, err
	case 2: // value.hashStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(HashOnlyNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &StorageAction_HashStorage{msg}
		return true, err
	case 3: // value.linkStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LinkNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &StorageAction_LinkStorage{msg}
		return true, err
	case 4: // value.encryptStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncryptNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &StorageAction_EncryptStorage{msg}
		return true, err
	case 5: // value.encryptShareStorage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(EncryptShareNotaryStorage)
		err := b.DecodeMessage(msg)
		m.Value = &StorageAction_EncryptShareStorage{msg}
		return true, err
	default:
		return false, nil
	}
}

func _StorageAction_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*StorageAction)
	// value
	switch x := m.Value.(type) {
	case *StorageAction_ContentStorage:
		s := proto.Size(x.ContentStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageAction_HashStorage:
		s := proto.Size(x.HashStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageAction_LinkStorage:
		s := proto.Size(x.LinkStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageAction_EncryptStorage:
		s := proto.Size(x.EncryptStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case *StorageAction_EncryptShareStorage:
		s := proto.Size(x.EncryptShareStorage)
		n += 1 // tag and wire
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// 内容存证模型
type ContentOnlyNotaryStorage struct {
	// 长度需要小于512k
	Content              []byte   `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ContentOnlyNotaryStorage) Reset()         { *m = ContentOnlyNotaryStorage{} }
func (m *ContentOnlyNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*ContentOnlyNotaryStorage) ProtoMessage()    {}
func (*ContentOnlyNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{2}
}
func (m *ContentOnlyNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContentOnlyNotaryStorage.Unmarshal(m, b)
}
func (m *ContentOnlyNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContentOnlyNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *ContentOnlyNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContentOnlyNotaryStorage.Merge(dst, src)
}
func (m *ContentOnlyNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_ContentOnlyNotaryStorage.Size(m)
}
func (m *ContentOnlyNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_ContentOnlyNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_ContentOnlyNotaryStorage proto.InternalMessageInfo

func (m *ContentOnlyNotaryStorage) GetContent() []byte {
	if m != nil {
		return m.Content
	}
	return nil
}

// 哈希存证模型，推荐使用sha256哈希，限制256位得摘要值
type HashOnlyNotaryStorage struct {
	// 长度固定为32字节
	Hash                 []byte   `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *HashOnlyNotaryStorage) Reset()         { *m = HashOnlyNotaryStorage{} }
func (m *HashOnlyNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*HashOnlyNotaryStorage) ProtoMessage()    {}
func (*HashOnlyNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{3}
}
func (m *HashOnlyNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_HashOnlyNotaryStorage.Unmarshal(m, b)
}
func (m *HashOnlyNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_HashOnlyNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *HashOnlyNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HashOnlyNotaryStorage.Merge(dst, src)
}
func (m *HashOnlyNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_HashOnlyNotaryStorage.Size(m)
}
func (m *HashOnlyNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_HashOnlyNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_HashOnlyNotaryStorage proto.InternalMessageInfo

func (m *HashOnlyNotaryStorage) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// 链接存证模型
type LinkNotaryStorage struct {
	// 存证内容的链接，可以写入URL,或者其他可用于定位源文件得线索.
	Link []byte `protobuf:"bytes,1,opt,name=link,proto3" json:"link,omitempty"`
	// 源文件得hash值，推荐使用sha256哈希，限制256位得摘要值
	Hash                 []byte   `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *LinkNotaryStorage) Reset()         { *m = LinkNotaryStorage{} }
func (m *LinkNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*LinkNotaryStorage) ProtoMessage()    {}
func (*LinkNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{4}
}
func (m *LinkNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_LinkNotaryStorage.Unmarshal(m, b)
}
func (m *LinkNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_LinkNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *LinkNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LinkNotaryStorage.Merge(dst, src)
}
func (m *LinkNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_LinkNotaryStorage.Size(m)
}
func (m *LinkNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_LinkNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_LinkNotaryStorage proto.InternalMessageInfo

func (m *LinkNotaryStorage) GetLink() []byte {
	if m != nil {
		return m.Link
	}
	return nil
}

func (m *LinkNotaryStorage) GetHash() []byte {
	if m != nil {
		return m.Hash
	}
	return nil
}

// 隐私存证模型，如果一个文件需要存证，且不公开内容，可以选择将源文件通过对称加密算法加密后上链
type EncryptNotaryStorage struct {
	// 存证明文内容的hash值，推荐使用sha256哈希，限制256位得摘要值
	ContentHash []byte `protobuf:"bytes,1,opt,name=contentHash,proto3" json:"contentHash,omitempty"`
	// 源文件得密文，由加密key及nonce对明文加密得到该值。
	EncryptContent []byte `protobuf:"bytes,2,opt,name=encryptContent,proto3" json:"encryptContent,omitempty"`
	// 加密iv，通过AES进行加密时制定随机生成的iv,解密时需要使用该值
	Nonce                []byte   `protobuf:"bytes,3,opt,name=nonce,proto3" json:"nonce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptNotaryStorage) Reset()         { *m = EncryptNotaryStorage{} }
func (m *EncryptNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*EncryptNotaryStorage) ProtoMessage()    {}
func (*EncryptNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{5}
}
func (m *EncryptNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptNotaryStorage.Unmarshal(m, b)
}
func (m *EncryptNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *EncryptNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptNotaryStorage.Merge(dst, src)
}
func (m *EncryptNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_EncryptNotaryStorage.Size(m)
}
func (m *EncryptNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptNotaryStorage proto.InternalMessageInfo

func (m *EncryptNotaryStorage) GetContentHash() []byte {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *EncryptNotaryStorage) GetEncryptContent() []byte {
	if m != nil {
		return m.EncryptContent
	}
	return nil
}

func (m *EncryptNotaryStorage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

// 隐私存证模型
type EncryptContentOnlyNotaryStorage struct {
	// 存证内容的hash值，推荐使用sha256哈希，限制256位得摘要值
	//   bytes contentHash   = 1;
	// 源文件得密文。
	EncryptContent []byte `protobuf:"bytes,1,opt,name=encryptContent,proto3" json:"encryptContent,omitempty"`
	// 加密iv，通过AES进行加密时制定随机生成的iv,解密时需要使用该值
	Nonce                []byte   `protobuf:"bytes,2,opt,name=nonce,proto3" json:"nonce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptContentOnlyNotaryStorage) Reset()         { *m = EncryptContentOnlyNotaryStorage{} }
func (m *EncryptContentOnlyNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*EncryptContentOnlyNotaryStorage) ProtoMessage()    {}
func (*EncryptContentOnlyNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{6}
}
func (m *EncryptContentOnlyNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptContentOnlyNotaryStorage.Unmarshal(m, b)
}
func (m *EncryptContentOnlyNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptContentOnlyNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *EncryptContentOnlyNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptContentOnlyNotaryStorage.Merge(dst, src)
}
func (m *EncryptContentOnlyNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_EncryptContentOnlyNotaryStorage.Size(m)
}
func (m *EncryptContentOnlyNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptContentOnlyNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptContentOnlyNotaryStorage proto.InternalMessageInfo

func (m *EncryptContentOnlyNotaryStorage) GetEncryptContent() []byte {
	if m != nil {
		return m.EncryptContent
	}
	return nil
}

func (m *EncryptContentOnlyNotaryStorage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

// 分享隐私存证模型,需要完备的sdk或者相应的密钥库支持
type EncryptShareNotaryStorage struct {
	// 存证明文内容的hash值，推荐使用sha256哈希，限制256位得摘要值
	ContentHash []byte `protobuf:"bytes,1,opt,name=contentHash,proto3" json:"contentHash,omitempty"`
	// 源文件得密文。
	EncryptContent []byte `protobuf:"bytes,2,opt,name=encryptContent,proto3" json:"encryptContent,omitempty"`
	// 密钥的kdf推导路径。密钥tree父节点根据该路径可以推导出私钥key
	KeyName []byte `protobuf:"bytes,3,opt,name=keyName,proto3" json:"keyName,omitempty"`
	// 加密key的wrap key。加密key随机生成，对明文进行加密，该key有私密key进行key wrap后公开。
	// 使用时，通过私密key对wrap key解密得到加密key对密文进行解密。
	KeyWrap []byte `protobuf:"bytes,4,opt,name=keyWrap,proto3" json:"keyWrap,omitempty"`
	// 加密iv，通过AES进行加密时制定随机生成的iv,解密时需要使用该值
	Nonce                []byte   `protobuf:"bytes,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *EncryptShareNotaryStorage) Reset()         { *m = EncryptShareNotaryStorage{} }
func (m *EncryptShareNotaryStorage) String() string { return proto.CompactTextString(m) }
func (*EncryptShareNotaryStorage) ProtoMessage()    {}
func (*EncryptShareNotaryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{7}
}
func (m *EncryptShareNotaryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EncryptShareNotaryStorage.Unmarshal(m, b)
}
func (m *EncryptShareNotaryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EncryptShareNotaryStorage.Marshal(b, m, deterministic)
}
func (dst *EncryptShareNotaryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EncryptShareNotaryStorage.Merge(dst, src)
}
func (m *EncryptShareNotaryStorage) XXX_Size() int {
	return xxx_messageInfo_EncryptShareNotaryStorage.Size(m)
}
func (m *EncryptShareNotaryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_EncryptShareNotaryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_EncryptShareNotaryStorage proto.InternalMessageInfo

func (m *EncryptShareNotaryStorage) GetContentHash() []byte {
	if m != nil {
		return m.ContentHash
	}
	return nil
}

func (m *EncryptShareNotaryStorage) GetEncryptContent() []byte {
	if m != nil {
		return m.EncryptContent
	}
	return nil
}

func (m *EncryptShareNotaryStorage) GetKeyName() []byte {
	if m != nil {
		return m.KeyName
	}
	return nil
}

func (m *EncryptShareNotaryStorage) GetKeyWrap() []byte {
	if m != nil {
		return m.KeyWrap
	}
	return nil
}

func (m *EncryptShareNotaryStorage) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

// 根据txhash去状态数据库中查询存储内容
type QueryStorage struct {
	TxHash               string   `protobuf:"bytes,1,opt,name=txHash,proto3" json:"txHash,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *QueryStorage) Reset()         { *m = QueryStorage{} }
func (m *QueryStorage) String() string { return proto.CompactTextString(m) }
func (*QueryStorage) ProtoMessage()    {}
func (*QueryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{8}
}
func (m *QueryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_QueryStorage.Unmarshal(m, b)
}
func (m *QueryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_QueryStorage.Marshal(b, m, deterministic)
}
func (dst *QueryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryStorage.Merge(dst, src)
}
func (m *QueryStorage) XXX_Size() int {
	return xxx_messageInfo_QueryStorage.Size(m)
}
func (m *QueryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_QueryStorage proto.InternalMessageInfo

func (m *QueryStorage) GetTxHash() string {
	if m != nil {
		return m.TxHash
	}
	return ""
}

// 批量查询有可能导致数据库崩溃
type BatchQueryStorage struct {
	TxHashs              []string `protobuf:"bytes,1,rep,name=txHashs,proto3" json:"txHashs,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchQueryStorage) Reset()         { *m = BatchQueryStorage{} }
func (m *BatchQueryStorage) String() string { return proto.CompactTextString(m) }
func (*BatchQueryStorage) ProtoMessage()    {}
func (*BatchQueryStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{9}
}
func (m *BatchQueryStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchQueryStorage.Unmarshal(m, b)
}
func (m *BatchQueryStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchQueryStorage.Marshal(b, m, deterministic)
}
func (dst *BatchQueryStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchQueryStorage.Merge(dst, src)
}
func (m *BatchQueryStorage) XXX_Size() int {
	return xxx_messageInfo_BatchQueryStorage.Size(m)
}
func (m *BatchQueryStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchQueryStorage.DiscardUnknown(m)
}

var xxx_messageInfo_BatchQueryStorage proto.InternalMessageInfo

func (m *BatchQueryStorage) GetTxHashs() []string {
	if m != nil {
		return m.TxHashs
	}
	return nil
}

type BatchReplyStorage struct {
	Storages             []*Storage `protobuf:"bytes,1,rep,name=storages,proto3" json:"storages,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BatchReplyStorage) Reset()         { *m = BatchReplyStorage{} }
func (m *BatchReplyStorage) String() string { return proto.CompactTextString(m) }
func (*BatchReplyStorage) ProtoMessage()    {}
func (*BatchReplyStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{10}
}
func (m *BatchReplyStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchReplyStorage.Unmarshal(m, b)
}
func (m *BatchReplyStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchReplyStorage.Marshal(b, m, deterministic)
}
func (dst *BatchReplyStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchReplyStorage.Merge(dst, src)
}
func (m *BatchReplyStorage) XXX_Size() int {
	return xxx_messageInfo_BatchReplyStorage.Size(m)
}
func (m *BatchReplyStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchReplyStorage.DiscardUnknown(m)
}

var xxx_messageInfo_BatchReplyStorage proto.InternalMessageInfo

func (m *BatchReplyStorage) GetStorages() []*Storage {
	if m != nil {
		return m.Storages
	}
	return nil
}

type ReceiptStorage struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReceiptStorage) Reset()         { *m = ReceiptStorage{} }
func (m *ReceiptStorage) String() string { return proto.CompactTextString(m) }
func (*ReceiptStorage) ProtoMessage()    {}
func (*ReceiptStorage) Descriptor() ([]byte, []int) {
	return fileDescriptor_storage_919e542fa62fc0e7, []int{11}
}
func (m *ReceiptStorage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReceiptStorage.Unmarshal(m, b)
}
func (m *ReceiptStorage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReceiptStorage.Marshal(b, m, deterministic)
}
func (dst *ReceiptStorage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiptStorage.Merge(dst, src)
}
func (m *ReceiptStorage) XXX_Size() int {
	return xxx_messageInfo_ReceiptStorage.Size(m)
}
func (m *ReceiptStorage) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiptStorage.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiptStorage proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Storage)(nil), "types.Storage")
	proto.RegisterType((*StorageAction)(nil), "types.StorageAction")
	proto.RegisterType((*ContentOnlyNotaryStorage)(nil), "types.ContentOnlyNotaryStorage")
	proto.RegisterType((*HashOnlyNotaryStorage)(nil), "types.HashOnlyNotaryStorage")
	proto.RegisterType((*LinkNotaryStorage)(nil), "types.LinkNotaryStorage")
	proto.RegisterType((*EncryptNotaryStorage)(nil), "types.EncryptNotaryStorage")
	proto.RegisterType((*EncryptContentOnlyNotaryStorage)(nil), "types.EncryptContentOnlyNotaryStorage")
	proto.RegisterType((*EncryptShareNotaryStorage)(nil), "types.EncryptShareNotaryStorage")
	proto.RegisterType((*QueryStorage)(nil), "types.QueryStorage")
	proto.RegisterType((*BatchQueryStorage)(nil), "types.BatchQueryStorage")
	proto.RegisterType((*BatchReplyStorage)(nil), "types.BatchReplyStorage")
	proto.RegisterType((*ReceiptStorage)(nil), "types.ReceiptStorage")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// StorageClient is the client API for Storage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type StorageClient interface {
}

type storageClient struct {
	cc *grpc.ClientConn
}

func NewStorageClient(cc *grpc.ClientConn) StorageClient {
	return &storageClient{cc}
}

// StorageServer is the server API for Storage service.
type StorageServer interface {
}

func RegisterStorageServer(s *grpc.Server, srv StorageServer) {
	s.RegisterService(&_Storage_serviceDesc, srv)
}

var _Storage_serviceDesc = grpc.ServiceDesc{
	ServiceName: "types.storage",
	HandlerType: (*StorageServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams:     []grpc.StreamDesc{},
	Metadata:    "storage.proto",
}

func init() { proto.RegisterFile("storage.proto", fileDescriptor_storage_919e542fa62fc0e7) }

var fileDescriptor_storage_919e542fa62fc0e7 = []byte{
	// 471 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xec, 0x54, 0xcf, 0x8b, 0xd3, 0x40,
	0x14, 0x36, 0xe9, 0xa6, 0xb1, 0x2f, 0xdd, 0xe0, 0x8e, 0xab, 0x8c, 0x28, 0x6c, 0x98, 0xc3, 0x52,
	0x14, 0x7b, 0xa8, 0xde, 0x14, 0xd4, 0x95, 0x42, 0x05, 0x59, 0x71, 0x14, 0x3c, 0xca, 0x18, 0x06,
	0x53, 0x5a, 0x27, 0x21, 0x99, 0x5d, 0xcc, 0x7f, 0xe1, 0x7f, 0xe2, 0xff, 0xe7, 0x49, 0x32, 0xf3,
	0x26, 0x4d, 0x9b, 0xd6, 0x93, 0x78, 0xf2, 0x96, 0xf7, 0xbe, 0xef, 0x7d, 0xef, 0xc7, 0x97, 0x04,
	0x8e, 0x2b, 0x9d, 0x97, 0xe2, 0xab, 0x9c, 0x16, 0x65, 0xae, 0x73, 0x12, 0xe8, 0xba, 0x90, 0x15,
	0xfb, 0xe5, 0x43, 0xf8, 0xc1, 0x02, 0xe4, 0x0d, 0xc4, 0x69, 0xae, 0xb4, 0x54, 0x1a, 0x33, 0xd4,
	0x4b, 0xbc, 0x49, 0x34, 0x3b, 0x9b, 0x1a, 0xee, 0xf4, 0xb5, 0x05, 0xdf, 0xa9, 0x75, 0x7d, 0x99,
	0x6b, 0x51, 0xd6, 0x48, 0x5b, 0xdc, 0xe0, 0x3b, 0x85, 0xe4, 0x25, 0x44, 0x99, 0xa8, 0x32, 0xa7,
	0xe3, 0x1b, 0x9d, 0x07, 0xa8, 0xb3, 0x10, 0x55, 0xb6, 0x4f, 0xa4, 0x5b, 0x42, 0x9e, 0x43, 0xb4,
	0x5e, 0xaa, 0x95, 0x53, 0x18, 0x18, 0x05, 0x8a, 0x0a, 0x6f, 0x97, 0x6a, 0xd5, 0xab, 0xee, 0xd0,
	0xc9, 0x1c, 0x62, 0xa9, 0xd2, 0xb2, 0x2e, 0xda, 0x55, 0x8e, 0x8c, 0xc0, 0x7d, 0x14, 0x98, 0x5b,
	0xb0, 0xb7, 0xc6, 0x76, 0x11, 0xf9, 0x08, 0xb7, 0x5d, 0x26, 0x13, 0xa5, 0x74, 0x5a, 0x81, 0xd1,
	0x4a, 0xb6, 0xb5, 0x0c, 0x63, 0x57, 0x70, 0x5f, 0xf9, 0x45, 0x08, 0xc1, 0xb5, 0x58, 0x5f, 0x49,
	0xf6, 0x63, 0x00, 0xc7, 0x98, 0x7c, 0x95, 0xea, 0x65, 0xae, 0xfe, 0x5b, 0xf0, 0x6f, 0x2c, 0x20,
	0x31, 0xf8, 0xba, 0xa6, 0xc3, 0xc4, 0x9b, 0x04, 0xdc, 0xd7, 0xf5, 0xc6, 0x92, 0xa7, 0x40, 0x0f,
	0xdd, 0x98, 0x50, 0x08, 0xf1, 0xc6, 0xc6, 0x95, 0x31, 0x77, 0x21, 0x7b, 0x04, 0x77, 0xf6, 0x5e,
	0x94, 0x10, 0x38, 0x6a, 0x2e, 0x8a, 0x7c, 0xf3, 0xcc, 0x9e, 0xc1, 0x49, 0xef, 0x78, 0x0d, 0xb1,
	0x39, 0x9e, 0x23, 0x36, 0xcf, 0x6d, 0xb1, 0xdf, 0x29, 0xbe, 0x86, 0xd3, 0x7d, 0x87, 0x23, 0x09,
	0x44, 0x38, 0xcc, 0x62, 0xd3, 0xaf, 0x9b, 0x22, 0xe7, 0xad, 0x1f, 0xb8, 0x20, 0xea, 0xee, 0x64,
	0xc9, 0x29, 0x04, 0x2a, 0x57, 0xa9, 0xf5, 0x7b, 0xcc, 0x6d, 0xc0, 0x3e, 0xc3, 0xd9, 0x7c, 0x8b,
	0xd7, 0xdf, 0xb5, 0xdf, 0xc0, 0xfb, 0x73, 0x03, 0xbf, 0xdb, 0xe0, 0xa7, 0x07, 0xf7, 0x0e, 0xda,
	0xf8, 0x17, 0xd7, 0xa3, 0x10, 0xae, 0x64, 0x7d, 0x29, 0xbe, 0xb9, 0x05, 0x5d, 0x88, 0xc8, 0xa7,
	0x52, 0x14, 0xe6, 0x4d, 0xb5, 0x48, 0x13, 0x6e, 0x26, 0x0e, 0xba, 0x13, 0x9f, 0xc3, 0xf8, 0xfd,
	0x95, 0xdc, 0xcc, 0x78, 0x17, 0x86, 0xfa, 0x7b, 0x3b, 0xde, 0x88, 0x63, 0xc4, 0x1e, 0xc3, 0xc9,
	0x85, 0xd0, 0x69, 0xb6, 0x45, 0xa6, 0x10, 0x5a, 0xb8, 0xa2, 0x5e, 0x32, 0x98, 0x8c, 0xb8, 0x0b,
	0xd9, 0x0b, 0xa4, 0x73, 0x59, 0xac, 0x5b, 0xfa, 0x43, 0xb8, 0x89, 0xbf, 0x6f, 0xcb, 0x8f, 0x66,
	0x31, 0xbe, 0xfa, 0xc8, 0xe0, 0x2d, 0xce, 0x6e, 0x41, 0xcc, 0x65, 0x2a, 0x97, 0xed, 0x37, 0x34,
	0x1b, 0x41, 0x88, 0xe8, 0x97, 0xa1, 0xf9, 0xfb, 0x3f, 0xf9, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x9e,
	0x3b, 0x2b, 0xb0, 0x0e, 0x06, 0x00, 0x00,
}
